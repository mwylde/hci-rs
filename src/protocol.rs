// This file was auto-generated by protogen and will be overwritten on every compile. Do not
// hand-edit. Instead update the protogen source files in src/protogen.

use protogen::*;

#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct L2capPacket {
    _packet_len: u16,
    _length: u16,
    _channel_id: u16,
    _payload: Vec<u8>,
}

impl L2capPacket {
    pub fn get_length(&self) -> u16 {
        self._length
    }

    pub fn get_channel_id(&self) -> u16 {
        self._channel_id
    }

    pub fn get_payload(&self) -> &[u8] {
        &self._payload
    }

    pub fn parse<'a>(_s0: State<'a>, _packet_len: u16) -> PResult<(State<'a>, L2capPacket)> {
        let (_s1, _length) = call!(_s0, read_u16_le)?;
        let (_s2, _channel_id) = call!(_s1, read_u16_le)?;
        let (_s3, _payload) = call!(_s2, count!(((_packet_len - 0x4)) as usize, call!(read_u8_le)))?;
        Ok((_s3, L2capPacket { _packet_len, _length, _channel_id, _payload }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._length);
        buf.push_u16_le(self._channel_id);
        buf.push_bytes(&self._payload);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct HciEvent {
    _event_code: u8,
    _parameter_length: u8,
    _data: Vec<u8>,
    _event: HciEvent_Event,
}

impl HciEvent {
    pub fn get_event(&self) -> &HciEvent_Event {
        &self._event
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8) -> PResult<(State<'a>, HciEvent)> {
        if 0x4 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _event_code) = call!(_s0, read_u8_le)?;
        let (_s2, _parameter_length) = call!(_s1, read_u8_le)?;
        let (_s3, _data) = call!(_s2, count!(_parameter_length as usize, call!(read_u8_le)))?;
        let (_, _event) = call!(_s2.range_to(.._parameter_length as usize), choose!(
            map!(call!(call!(DisconnectionComplete::parse, _event_code)), |v| HciEvent_Event::DisconnectionComplete(v)) |
            map!(call!(call!(CommandComplete::parse, _event_code)), |v| HciEvent_Event::CommandComplete(v)) |
            map!(call!(call!(LeMetaEvent::parse, _event_code)), |v| HciEvent_Event::LeMetaEvent(v)) |
            map!(call!(call!(UnknownEvent::parse, _event_code)), |v| HciEvent_Event::UnknownEvent(v))
    ))?;
        Ok((_s3, HciEvent { _event_code, _parameter_length, _data, _event }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._event_code);
        buf.push_u8(self._parameter_length);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct UnknownEvent {
    _event_code: u8,
    _data: Vec<u8>,
}

impl UnknownEvent {
    pub fn get_event_code(&self) -> u8 {
        self._event_code
    }

    pub fn get_data(&self) -> &[u8] {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>, _event_code: u8) -> PResult<(State<'a>, UnknownEvent)> {
        let (_s1, _data) = call!(_s0, rest)?;
        Ok((_s1, UnknownEvent { _event_code, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct DisconnectionComplete {
    _status: ResponseStatus,
    _connection_handle: u16,
    _reason: u8,
}

impl DisconnectionComplete {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_connection_handle(&self) -> u16 {
        self._connection_handle
    }

    pub fn get_reason(&self) -> u8 {
        self._reason
    }

    pub fn parse<'a>(_s0: State<'a>, _event_code: u8) -> PResult<(State<'a>, DisconnectionComplete)> {
        if 0x5 != _event_code {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _connection_handle) = call!(_s1, read_u16_le)?;
        let (_s3, _reason) = call!(_s2, read_u8_le)?;
        Ok((_s3, DisconnectionComplete { _status, _connection_handle, _reason }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._connection_handle);
        buf.push_u8(self._reason);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct CommandComplete {
    _num_packets: u8,
    _ogf: u8,
    _ocf: u16,
    _response: CommandComplete_Response,
}

impl CommandComplete {
    pub fn get_num_packets(&self) -> u8 {
        self._num_packets
    }

    pub fn get_response(&self) -> &CommandComplete_Response {
        &self._response
    }

    pub fn parse<'a>(_s0: State<'a>, _event_code: u8) -> PResult<(State<'a>, CommandComplete)> {
        if 0xE != _event_code {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _num_packets) = call!(_s0, read_u8_le)?;
        let (_s2, _ogf) = call!(_s1, call!(read_bits_u8, 6))?;
        let (_s3, _ocf) = call!(_s2, call!(read_bits_u16, 10))?;
        let (_s4, _response) = call!(_s3, choose!(
            map!(call!(call!(NoAssociatedCommand::parse, _ogf, _ocf)), |v| CommandComplete_Response::NoAssociatedCommand(v)) |
            map!(call!(call!(DisconnectResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::Disconnect(v)) |
            map!(call!(call!(ResetResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::Reset(v)) |
            map!(call!(call!(SetEventFilterResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::SetEventFilter(v)) |
            map!(call!(call!(FlushResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::Flush(v)) |
            map!(call!(call!(WriteLocalNameResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WriteLocalName(v)) |
            map!(call!(call!(ReadLocalNameResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadLocalName(v)) |
            map!(call!(call!(ReadConnectionAcceptTimeoutResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadConnectionAcceptTimeout(v)) |
            map!(call!(call!(WriteConnectionAcceptTimeoutResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WriteConnectionAcceptTimeout(v)) |
            map!(call!(call!(ReadPageTimeoutResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadPageTimeout(v)) |
            map!(call!(call!(WritePageTimeoutResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WritePageTimeout(v)) |
            map!(call!(call!(ReadScanEnableResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadScanEnable(v)) |
            map!(call!(call!(WriteScanEnableResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WriteScanEnable(v)) |
            map!(call!(call!(ReadPageScanActivityResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadPageScanActivity(v)) |
            map!(call!(call!(WritePageScanActivityResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WritePageScanActivity(v)) |
            map!(call!(call!(ReadInquiryScanActivityResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadInquiryScanActivity(v)) |
            map!(call!(call!(WriteInquiryScanActivityResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WriteInquiryScanActivity(v)) |
            map!(call!(call!(ReadExtendedInquiryResponseResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadExtendedInquiryResponse(v)) |
            map!(call!(call!(WriteExtendedInquiryResponseResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WriteExtendedInquiryResponse(v)) |
            map!(call!(call!(ReadLeHostSupportResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::ReadLeHostSupport(v)) |
            map!(call!(call!(WriteLeHostSupportResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::WriteLeHostSupport(v)) |
            map!(call!(call!(LeSetEventMask::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeSetEventMask(v)) |
            map!(call!(call!(LeSetEventMaskResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeSetEventMaskResponse(v)) |
            map!(call!(call!(LeReadBufferSizeResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeReadBufferSize(v)) |
            map!(call!(call!(LeReadLocalSupportedFeaturesResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeReadLocalSupportedFeatures(v)) |
            map!(call!(call!(LeSetRandomAddressCommandResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeSetRandomAddressCommand(v)) |
            map!(call!(call!(LeSetAdvertisingParametersResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeSetAdvertisingParameters(v)) |
            map!(call!(call!(LeSetAdvertisingDataResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LESetAdvertisingData(v)) |
            map!(call!(call!(LeSetScanParametersResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeSetScanParameters(v)) |
            map!(call!(call!(LeSetScanEnableResponse::parse, _ogf, _ocf)), |v| CommandComplete_Response::LeSetScanEnable(v)) |
            map!(call!(call!(UnknownCommand::parse, _ogf, _ocf)), |v| CommandComplete_Response::UnknownCommand(v))
    ))?;
        Ok((_s4, CommandComplete { _num_packets, _ogf, _ocf, _response }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._num_packets);
        for _v in 0..6 { buf.push_bit(self._ogf & (1 << _v) > 0) }
        for _v in 0..10 { buf.push_bit(self._ocf & (1 << _v) > 0) }
        match &self._response {
            CommandComplete_Response::NoAssociatedCommand(v) => v.write_bytes(buf),
            CommandComplete_Response::Disconnect(v) => v.write_bytes(buf),
            CommandComplete_Response::Reset(v) => v.write_bytes(buf),
            CommandComplete_Response::SetEventFilter(v) => v.write_bytes(buf),
            CommandComplete_Response::Flush(v) => v.write_bytes(buf),
            CommandComplete_Response::WriteLocalName(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadLocalName(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadConnectionAcceptTimeout(v) => v.write_bytes(buf),
            CommandComplete_Response::WriteConnectionAcceptTimeout(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadPageTimeout(v) => v.write_bytes(buf),
            CommandComplete_Response::WritePageTimeout(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadScanEnable(v) => v.write_bytes(buf),
            CommandComplete_Response::WriteScanEnable(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadPageScanActivity(v) => v.write_bytes(buf),
            CommandComplete_Response::WritePageScanActivity(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadInquiryScanActivity(v) => v.write_bytes(buf),
            CommandComplete_Response::WriteInquiryScanActivity(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadExtendedInquiryResponse(v) => v.write_bytes(buf),
            CommandComplete_Response::WriteExtendedInquiryResponse(v) => v.write_bytes(buf),
            CommandComplete_Response::ReadLeHostSupport(v) => v.write_bytes(buf),
            CommandComplete_Response::WriteLeHostSupport(v) => v.write_bytes(buf),
            CommandComplete_Response::LeSetEventMask(v) => v.write_bytes(buf),
            CommandComplete_Response::LeSetEventMaskResponse(v) => v.write_bytes(buf),
            CommandComplete_Response::LeReadBufferSize(v) => v.write_bytes(buf),
            CommandComplete_Response::LeReadLocalSupportedFeatures(v) => v.write_bytes(buf),
            CommandComplete_Response::LeSetRandomAddressCommand(v) => v.write_bytes(buf),
            CommandComplete_Response::LeSetAdvertisingParameters(v) => v.write_bytes(buf),
            CommandComplete_Response::LESetAdvertisingData(v) => v.write_bytes(buf),
            CommandComplete_Response::LeSetScanParameters(v) => v.write_bytes(buf),
            CommandComplete_Response::LeSetScanEnable(v) => v.write_bytes(buf),
            CommandComplete_Response::UnknownCommand(v) => v.write_bytes(buf),
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct NoAssociatedCommand {
    _ogf: u8,
}

impl NoAssociatedCommand {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, NoAssociatedCommand)> {
        if 0x0 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, NoAssociatedCommand { _ogf }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct UnknownCommand {
    _ogf: u8,
    _ocf: u16,
    _status: ResponseStatus,
    _data: Vec<u8>,
}

impl UnknownCommand {
    pub fn get_ogf(&self) -> u8 {
        self._ogf
    }

    pub fn get_ocf(&self) -> u16 {
        self._ocf
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, UnknownCommand)> {
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _data) = call!(_s1, rest)?;
        Ok((_s2, UnknownCommand { _ogf, _ocf, _status, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct EndThing2 {
}

impl EndThing2 {
    pub fn parse<'a>(_s0: State<'a>) -> PResult<(State<'a>, EndThing2)> {
        Ok((_s0, EndThing2 {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct HciCommand {
    _ogf: u8,
    _ocf: u16,
    _length: u8,
    _data: Vec<u8>,
    _command: HciCommand_Command,
}

impl HciCommand {
    pub fn get_command(&self) -> &HciCommand_Command {
        &self._command
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8) -> PResult<(State<'a>, HciCommand)> {
        if 0x1 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _ogf) = call!(_s0, call!(read_bits_u8, 6))?;
        let (_s2, _ocf) = call!(_s1, call!(read_bits_u16, 10))?;
        let (_s3, _length) = call!(_s2, read_u8_le)?;
        let (_s4, _data) = call!(_s3, count!(_length as usize, call!(read_u8_le)))?;
        let (_, _command) = call!(_s3.range_to(.._length as usize), choose!(
            map!(call!(call!(Disconnect::parse, _ogf, _ocf)), |v| HciCommand_Command::Disconnect(v)) |
            map!(call!(call!(Reset::parse, _ogf, _ocf)), |v| HciCommand_Command::Reset(v)) |
            map!(call!(call!(SetEventFilter::parse, _ogf, _ocf)), |v| HciCommand_Command::SetEventFilter(v)) |
            map!(call!(call!(Flush::parse, _ogf, _ocf)), |v| HciCommand_Command::Flush(v)) |
            map!(call!(call!(WriteLocalName::parse, _ogf, _ocf)), |v| HciCommand_Command::WriteLocalName(v)) |
            map!(call!(call!(ReadLocalName::parse, _ogf, _ocf)), |v| HciCommand_Command::ReadLocalName(v)) |
            map!(call!(call!(ReadConnectionAcceptTimeout::parse, _ogf, _ocf)), |v| HciCommand_Command::ReadConnectionAcceptTimeout(v)) |
            map!(call!(call!(WriteConnectionAcceptTimeout::parse, _ogf, _ocf)), |v| HciCommand_Command::WriteConnectionAcceptTimeout(v)) |
            map!(call!(call!(ReadPageTimeout::parse, _ogf, _ocf)), |v| HciCommand_Command::ReadPageTimeout(v)) |
            map!(call!(call!(WritePageTimeout::parse, _ogf, _ocf)), |v| HciCommand_Command::WritePageTimeout(v)) |
            map!(call!(call!(ReadScanEnable::parse, _ogf, _ocf)), |v| HciCommand_Command::ReadScanEnable(v)) |
            map!(call!(call!(WriteScanEnable::parse, _ogf, _ocf)), |v| HciCommand_Command::WriteScanEnable(v)) |
            map!(call!(call!(ReadPageScanActivity::parse, _ogf, _ocf)), |v| HciCommand_Command::ReadPageScanActivity(v)) |
            map!(call!(call!(WritePageScanActivity::parse, _ogf, _ocf)), |v| HciCommand_Command::WritePageScanActivity(v)) |
            map!(call!(call!(ReadInquiryScanActivity::parse, _ogf, _ocf)), |v| HciCommand_Command::ReadInquiryScanActivity(v)) |
            map!(call!(call!(WriteInquiryScanActivity::parse, _ogf, _ocf)), |v| HciCommand_Command::WriteInquiryScanActivity(v)) |
            map!(call!(call!(LeSetAdvertisingData::parse, _ogf, _ocf)), |v| HciCommand_Command::LESetAdvertisingData(v)) |
            map!(call!(call!(Unknown::parse, _ogf, _ocf)), |v| HciCommand_Command::Unknown(v))
    ))?;
        Ok((_s4, HciCommand { _ogf, _ocf, _length, _data, _command }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for _v in 0..6 { buf.push_bit(self._ogf & (1 << _v) > 0) }
        for _v in 0..10 { buf.push_bit(self._ocf & (1 << _v) > 0) }
        buf.push_u8(self._length);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ResponseStatus {
    _status_code: u8,
}

impl ResponseStatus {
    pub fn get_status_code(&self) -> u8 {
        self._status_code
    }

    pub fn parse<'a>(_s0: State<'a>) -> PResult<(State<'a>, ResponseStatus)> {
        let (_s1, _status_code) = call!(_s0, read_u8_le)?;
        Ok((_s1, ResponseStatus { _status_code }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._status_code);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct Unknown {
    _ogf: u8,
    _ocf: u16,
}

impl Unknown {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, Unknown)> {
        Ok((_s0, Unknown { _ogf, _ocf }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct Disconnect {
    _connection_handle: u16,
    _reason: u8,
}

impl Disconnect {
    pub fn get_connection_handle(&self) -> u16 {
        self._connection_handle
    }

    pub fn get_reason(&self) -> u8 {
        self._reason
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, Disconnect)> {
        if 0x1 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x6 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _connection_handle) = call!(_s0, read_u16_le)?;
        let (_s2, _reason) = call!(_s1, read_u8_le)?;
        Ok((_s2, Disconnect { _connection_handle, _reason }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._connection_handle);
        buf.push_u8(self._reason);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct DisconnectResponse {
    _status: ResponseStatus,
}

impl DisconnectResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, DisconnectResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x3 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, DisconnectResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct Reset {
}

impl Reset {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, Reset)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x3 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, Reset {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ResetResponse {
    _status: ResponseStatus,
}

impl ResetResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ResetResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x3 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, ResetResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct SetEventFilter {
    _filter_type: u8,
    _filter: SetEventFilter_Filter,
}

impl SetEventFilter {
    pub fn get_filter(&self) -> &SetEventFilter_Filter {
        &self._filter
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, SetEventFilter)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x5 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _filter_type) = call!(_s0, read_u8_le)?;
        let (_s2, _filter) = call!(_s1, choose!(
            map!(call!(call!(ClearAllFilter::parse, _filter_type)), |v| SetEventFilter_Filter::ClearAllFilter(v)) |
            map!(call!(call!(InquiryResult::parse, _filter_type)), |v| SetEventFilter_Filter::InquiryResult(v)) |
            map!(call!(call!(ConnectionSetup::parse, _filter_type)), |v| SetEventFilter_Filter::ConnectionSetup(v))
    ))?;
        Ok((_s2, SetEventFilter { _filter_type, _filter }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._filter_type);
        match &self._filter {
            SetEventFilter_Filter::ClearAllFilter(v) => v.write_bytes(buf),
            SetEventFilter_Filter::InquiryResult(v) => v.write_bytes(buf),
            SetEventFilter_Filter::ConnectionSetup(v) => v.write_bytes(buf),
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct SetEventFilterResponse {
    _status: ResponseStatus,
}

impl SetEventFilterResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, SetEventFilterResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x5 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, SetEventFilterResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct InquiryResult {
    _condition: FilterCondition,
}

impl InquiryResult {
    pub fn get_condition(&self) -> &FilterCondition {
        &self._condition
    }

    pub fn parse<'a>(_s0: State<'a>, _filter_type: u8) -> PResult<(State<'a>, InquiryResult)> {
        if 0x1 != _filter_type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _condition) = call!(_s0, FilterCondition::parse)?;
        Ok((_s1, InquiryResult { _condition }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._condition).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ConnectionSetup {
    _condition: FilterCondition,
    _auto_accept: u8,
}

impl ConnectionSetup {
    pub fn get_condition(&self) -> &FilterCondition {
        &self._condition
    }

    pub fn get_auto_accept(&self) -> u8 {
        self._auto_accept
    }

    pub fn parse<'a>(_s0: State<'a>, _filter_type: u8) -> PResult<(State<'a>, ConnectionSetup)> {
        if 0x2 != _filter_type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _condition) = call!(_s0, FilterCondition::parse)?;
        let (_s2, _auto_accept) = call!(_s1, read_u8_le)?;
        Ok((_s2, ConnectionSetup { _condition, _auto_accept }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._condition).write_bytes(buf);
        buf.push_u8(self._auto_accept);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct FilterCondition {
    _condition_type: u8,
    _value: FilterCondition_Value,
}

impl FilterCondition {
    pub fn get_value(&self) -> &FilterCondition_Value {
        &self._value
    }

    pub fn parse<'a>(_s0: State<'a>) -> PResult<(State<'a>, FilterCondition)> {
        let (_s1, _condition_type) = call!(_s0, read_u8_le)?;
        let (_s2, _value) = call!(_s1, choose!(
            map!(call!(call!(AllDevices::parse, _condition_type)), |v| FilterCondition_Value::AllDevices(v)) |
            map!(call!(call!(MatchClass::parse, _condition_type)), |v| FilterCondition_Value::MatchClass(v)) |
            map!(call!(call!(MatchAddress::parse, _condition_type)), |v| FilterCondition_Value::MatchAddress(v))
    ))?;
        Ok((_s2, FilterCondition { _condition_type, _value }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._condition_type);
        match &self._value {
            FilterCondition_Value::AllDevices(v) => v.write_bytes(buf),
            FilterCondition_Value::MatchClass(v) => v.write_bytes(buf),
            FilterCondition_Value::MatchAddress(v) => v.write_bytes(buf),
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ClearAllFilter {
}

impl ClearAllFilter {
    pub fn parse<'a>(_s0: State<'a>, _filter_type: u8) -> PResult<(State<'a>, ClearAllFilter)> {
        if 0x0 != _filter_type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ClearAllFilter {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct AllDevices {
}

impl AllDevices {
    pub fn parse<'a>(_s0: State<'a>, _condition_type: u8) -> PResult<(State<'a>, AllDevices)> {
        if 0x0 != _condition_type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, AllDevices {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct MatchClass {
    _class_of_device: Vec<u8>,
    _class_of_device_mask: Vec<u8>,
}

impl MatchClass {
    pub fn get_class_of_device(&self) -> &[u8] {
        &self._class_of_device
    }

    pub fn get_class_of_device_mask(&self) -> &[u8] {
        &self._class_of_device_mask
    }

    pub fn parse<'a>(_s0: State<'a>, _condition_type: u8) -> PResult<(State<'a>, MatchClass)> {
        if 0x1 != _condition_type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _class_of_device) = call!(_s0, count!(3, call!(read_u8_le)))?;
        let (_s2, _class_of_device_mask) = call!(_s1, count!(3, call!(read_u8_le)))?;
        Ok((_s2, MatchClass { _class_of_device, _class_of_device_mask }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._class_of_device);
        buf.push_bytes(&self._class_of_device_mask);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct MatchAddress {
    _address: Vec<u8>,
}

impl MatchAddress {
    pub fn get_address(&self) -> &[u8] {
        &self._address
    }

    pub fn parse<'a>(_s0: State<'a>, _condition_type: u8) -> PResult<(State<'a>, MatchAddress)> {
        if 0x2 != _condition_type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _address) = call!(_s0, count!(6, call!(read_u8_le)))?;
        Ok((_s1, MatchAddress { _address }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._address);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct Flush {
    _connection_handle: u16,
}

impl Flush {
    pub fn get_connection_handle(&self) -> u16 {
        self._connection_handle
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, Flush)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x8 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _connection_handle) = call!(_s0, read_u16_le)?;
        Ok((_s1, Flush { _connection_handle }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._connection_handle);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct FlushResponse {
    _status: ResponseStatus,
    _connection_handle: u16,
}

impl FlushResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_connection_handle(&self) -> u16 {
        self._connection_handle
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, FlushResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x8 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _connection_handle) = call!(_s1, read_u16_le)?;
        Ok((_s2, FlushResponse { _status, _connection_handle }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._connection_handle);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteLocalName {
    _local_name_buffer: Vec<u8>,
    _local_name: String,
}

impl WriteLocalName {
    pub fn get_local_name(&self) -> &String {
        &self._local_name
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteLocalName)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x13 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _local_name_buffer) = call!(_s0, count!(248, call!(read_u8_le)))?;
        let (_, _local_name) = call!(_s0.range_to(..248 as usize), map_res!(many!(call!(not, 0)), |v| String::from_utf8(v)))?;
        Ok((_s1, WriteLocalName { _local_name_buffer, _local_name }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._local_name_buffer);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteLocalNameResponse {
    _status: ResponseStatus,
}

impl WriteLocalNameResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteLocalNameResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x13 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WriteLocalNameResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadLocalName {
}

impl ReadLocalName {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadLocalName)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x14 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadLocalName {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadLocalNameResponse {
    _status: ResponseStatus,
    _local_name_buffer: Vec<u8>,
    _local_name: String,
}

impl ReadLocalNameResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_local_name(&self) -> &String {
        &self._local_name
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadLocalNameResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x14 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _local_name_buffer) = call!(_s1, count!(248, call!(read_u8_le)))?;
        let (_, _local_name) = call!(_s1.range_to(..248 as usize), map_res!(many!(call!(not, 0)), |v| String::from_utf8(v)))?;
        Ok((_s2, ReadLocalNameResponse { _status, _local_name_buffer, _local_name }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_bytes(&self._local_name_buffer);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadConnectionAcceptTimeout {
}

impl ReadConnectionAcceptTimeout {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadConnectionAcceptTimeout)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x15 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadConnectionAcceptTimeout {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadConnectionAcceptTimeoutResponse {
    _status: ResponseStatus,
    _connection_accept_timeout: u16,
}

impl ReadConnectionAcceptTimeoutResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_connection_accept_timeout(&self) -> u16 {
        self._connection_accept_timeout
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadConnectionAcceptTimeoutResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x15 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _connection_accept_timeout) = call!(_s1, read_u16_le)?;
        Ok((_s2, ReadConnectionAcceptTimeoutResponse { _status, _connection_accept_timeout }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._connection_accept_timeout);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteConnectionAcceptTimeout {
    _connection_accept_timeout: u16,
}

impl WriteConnectionAcceptTimeout {
    pub fn get_connection_accept_timeout(&self) -> u16 {
        self._connection_accept_timeout
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteConnectionAcceptTimeout)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x16 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _connection_accept_timeout) = call!(_s0, read_u16_le)?;
        Ok((_s1, WriteConnectionAcceptTimeout { _connection_accept_timeout }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._connection_accept_timeout);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteConnectionAcceptTimeoutResponse {
    _status: ResponseStatus,
}

impl WriteConnectionAcceptTimeoutResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteConnectionAcceptTimeoutResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x16 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WriteConnectionAcceptTimeoutResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadPageTimeout {
}

impl ReadPageTimeout {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadPageTimeout)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x17 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadPageTimeout {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadPageTimeoutResponse {
    _status: ResponseStatus,
    _page_timeout: u16,
}

impl ReadPageTimeoutResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_page_timeout(&self) -> u16 {
        self._page_timeout
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadPageTimeoutResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x17 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _page_timeout) = call!(_s1, read_u16_le)?;
        Ok((_s2, ReadPageTimeoutResponse { _status, _page_timeout }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._page_timeout);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WritePageTimeout {
    _page_timeout: u16,
}

impl WritePageTimeout {
    pub fn get_page_timeout(&self) -> u16 {
        self._page_timeout
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WritePageTimeout)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x18 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _page_timeout) = call!(_s0, read_u16_le)?;
        Ok((_s1, WritePageTimeout { _page_timeout }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._page_timeout);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WritePageTimeoutResponse {
    _status: ResponseStatus,
}

impl WritePageTimeoutResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WritePageTimeoutResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x18 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WritePageTimeoutResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadScanEnable {
}

impl ReadScanEnable {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadScanEnable)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x19 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadScanEnable {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadScanEnableResponse {
    _status: ResponseStatus,
    _scan_enable: u8,
}

impl ReadScanEnableResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_scan_enable(&self) -> u8 {
        self._scan_enable
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadScanEnableResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x19 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _scan_enable) = call!(_s1, read_u8_le)?;
        Ok((_s2, ReadScanEnableResponse { _status, _scan_enable }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u8(self._scan_enable);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteScanEnable {
    _scan_enable: u8,
}

impl WriteScanEnable {
    pub fn get_scan_enable(&self) -> u8 {
        self._scan_enable
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteScanEnable)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1A != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _scan_enable) = call!(_s0, read_u8_le)?;
        Ok((_s1, WriteScanEnable { _scan_enable }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._scan_enable);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteScanEnableResponse {
    _status: ResponseStatus,
}

impl WriteScanEnableResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteScanEnableResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1A != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WriteScanEnableResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadPageScanActivity {
}

impl ReadPageScanActivity {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadPageScanActivity)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1B != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadPageScanActivity {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadPageScanActivityResponse {
    _status: ResponseStatus,
    _page_scan_interval: u16,
    _page_scan_window: u16,
}

impl ReadPageScanActivityResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_page_scan_interval(&self) -> u16 {
        self._page_scan_interval
    }

    pub fn get_page_scan_window(&self) -> u16 {
        self._page_scan_window
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadPageScanActivityResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1B != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _page_scan_interval) = call!(_s1, read_u16_le)?;
        let (_s3, _page_scan_window) = call!(_s2, read_u16_le)?;
        Ok((_s3, ReadPageScanActivityResponse { _status, _page_scan_interval, _page_scan_window }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._page_scan_interval);
        buf.push_u16_le(self._page_scan_window);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WritePageScanActivity {
    _page_scan_interval: u16,
    _page_scan_window: u16,
}

impl WritePageScanActivity {
    pub fn get_page_scan_interval(&self) -> u16 {
        self._page_scan_interval
    }

    pub fn get_page_scan_window(&self) -> u16 {
        self._page_scan_window
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WritePageScanActivity)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1C != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _page_scan_interval) = call!(_s0, read_u16_le)?;
        let (_s2, _page_scan_window) = call!(_s1, read_u16_le)?;
        Ok((_s2, WritePageScanActivity { _page_scan_interval, _page_scan_window }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._page_scan_interval);
        buf.push_u16_le(self._page_scan_window);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WritePageScanActivityResponse {
    _status: ResponseStatus,
}

impl WritePageScanActivityResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WritePageScanActivityResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1C != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WritePageScanActivityResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadInquiryScanActivity {
}

impl ReadInquiryScanActivity {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadInquiryScanActivity)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1D != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadInquiryScanActivity {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadInquiryScanActivityResponse {
    _status: ResponseStatus,
    _inquiry_scan_interval: u16,
    _inquiry_scan_window: u16,
}

impl ReadInquiryScanActivityResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_inquiry_scan_interval(&self) -> u16 {
        self._inquiry_scan_interval
    }

    pub fn get_inquiry_scan_window(&self) -> u16 {
        self._inquiry_scan_window
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadInquiryScanActivityResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1D != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _inquiry_scan_interval) = call!(_s1, read_u16_le)?;
        let (_s3, _inquiry_scan_window) = call!(_s2, read_u16_le)?;
        Ok((_s3, ReadInquiryScanActivityResponse { _status, _inquiry_scan_interval, _inquiry_scan_window }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._inquiry_scan_interval);
        buf.push_u16_le(self._inquiry_scan_window);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteInquiryScanActivity {
    _inquiry_scan_interval: u16,
    _inquiry_scan_window: u16,
}

impl WriteInquiryScanActivity {
    pub fn get_inquiry_scan_interval(&self) -> u16 {
        self._inquiry_scan_interval
    }

    pub fn get_inquiry_scan_window(&self) -> u16 {
        self._inquiry_scan_window
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteInquiryScanActivity)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1E != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _inquiry_scan_interval) = call!(_s0, read_u16_le)?;
        let (_s2, _inquiry_scan_window) = call!(_s1, read_u16_le)?;
        Ok((_s2, WriteInquiryScanActivity { _inquiry_scan_interval, _inquiry_scan_window }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._inquiry_scan_interval);
        buf.push_u16_le(self._inquiry_scan_window);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteInquiryScanActivityResponse {
    _status: ResponseStatus,
}

impl WriteInquiryScanActivityResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteInquiryScanActivityResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1E != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WriteInquiryScanActivityResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadExtendedInquiryResponse {
}

impl ReadExtendedInquiryResponse {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadExtendedInquiryResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x51 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadExtendedInquiryResponse {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadExtendedInquiryResponseResponse {
    _status: ResponseStatus,
    _fec_required: u8,
    _response_buffer: Vec<u8>,
    _advertising_data: Vec<BasicDataType>,
}

impl ReadExtendedInquiryResponseResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_fec_required(&self) -> u8 {
        self._fec_required
    }

    pub fn get_advertising_data(&self) -> &[BasicDataType] {
        &self._advertising_data
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadExtendedInquiryResponseResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x51 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _fec_required) = call!(_s1, read_u8_le)?;
        let (_s3, _response_buffer) = call!(_s2, count!(240, call!(read_u8_le)))?;
        let (_, _advertising_data) = call!(_s2.range_to(..240 as usize), many!(call!(BasicDataType::parse)))?;
        Ok((_s3, ReadExtendedInquiryResponseResponse { _status, _fec_required, _response_buffer, _advertising_data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u8(self._fec_required);
        buf.push_bytes(&self._response_buffer);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteExtendedInquiryResponse {
    _fec_required: u8,
    _response_buffer: Vec<u8>,
    _advertising_data: Vec<BasicDataType>,
}

impl WriteExtendedInquiryResponse {
    pub fn get_fec_required(&self) -> u8 {
        self._fec_required
    }

    pub fn get_advertising_data(&self) -> &[BasicDataType] {
        &self._advertising_data
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteExtendedInquiryResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x52 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _fec_required) = call!(_s0, read_u8_le)?;
        let (_s2, _response_buffer) = call!(_s1, count!(240, call!(read_u8_le)))?;
        let (_, _advertising_data) = call!(_s1.range_to(..240 as usize), many!(call!(BasicDataType::parse)))?;
        Ok((_s2, WriteExtendedInquiryResponse { _fec_required, _response_buffer, _advertising_data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._fec_required);
        buf.push_bytes(&self._response_buffer);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteExtendedInquiryResponseResponse {
    _status: ResponseStatus,
}

impl WriteExtendedInquiryResponseResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteExtendedInquiryResponseResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x52 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WriteExtendedInquiryResponseResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadLeHostSupport {
}

impl ReadLeHostSupport {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadLeHostSupport)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x6C != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, ReadLeHostSupport {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ReadLeHostSupportResponse {
    _status: ResponseStatus,
    _le_supported_host: u8,
    _simultaneous_le_host: u8,
}

impl ReadLeHostSupportResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_le_supported_host(&self) -> u8 {
        self._le_supported_host
    }

    pub fn get_simultaneous_le_host(&self) -> u8 {
        self._simultaneous_le_host
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, ReadLeHostSupportResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x6C != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _le_supported_host) = call!(_s1, read_u8_le)?;
        let (_s3, _simultaneous_le_host) = call!(_s2, read_u8_le)?;
        Ok((_s3, ReadLeHostSupportResponse { _status, _le_supported_host, _simultaneous_le_host }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u8(self._le_supported_host);
        buf.push_u8(self._simultaneous_le_host);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteLeHostSupport {
    _le_supported_host: u8,
    _simultaneous_le_host: u8,
}

impl WriteLeHostSupport {
    pub fn get_le_supported_host(&self) -> u8 {
        self._le_supported_host
    }

    pub fn get_simultaneous_le_host(&self) -> u8 {
        self._simultaneous_le_host
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteLeHostSupport)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x6D != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _le_supported_host) = call!(_s0, read_u8_le)?;
        let (_s2, _simultaneous_le_host) = call!(_s1, read_u8_le)?;
        Ok((_s2, WriteLeHostSupport { _le_supported_host, _simultaneous_le_host }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._le_supported_host);
        buf.push_u8(self._simultaneous_le_host);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct WriteLeHostSupportResponse {
    _status: ResponseStatus,
}

impl WriteLeHostSupportResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, WriteLeHostSupportResponse)> {
        if 0x3 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x6D != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, WriteLeHostSupportResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetEventMask {
    _le_event_mask: Vec<u8>,
}

impl LeSetEventMask {
    pub fn get_le_event_mask(&self) -> &[u8] {
        &self._le_event_mask
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetEventMask)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _le_event_mask) = call!(_s0, count!(8, call!(read_u8_le)))?;
        Ok((_s1, LeSetEventMask { _le_event_mask }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._le_event_mask);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetEventMaskResponse {
    _status: ResponseStatus,
}

impl LeSetEventMaskResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetEventMaskResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, LeSetEventMaskResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeReadBufferSize {
}

impl LeReadBufferSize {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeReadBufferSize)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x2 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, LeReadBufferSize {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeReadBufferSizeResponse {
    _status: ResponseStatus,
    _hc_le_data_packet_length: u16,
    _hc_total_num_le_data_packets: u8,
}

impl LeReadBufferSizeResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_hc_le_data_packet_length(&self) -> u16 {
        self._hc_le_data_packet_length
    }

    pub fn get_hc_total_num_le_data_packets(&self) -> u8 {
        self._hc_total_num_le_data_packets
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeReadBufferSizeResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x2 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _hc_le_data_packet_length) = call!(_s1, read_u16_le)?;
        let (_s3, _hc_total_num_le_data_packets) = call!(_s2, read_u8_le)?;
        Ok((_s3, LeReadBufferSizeResponse { _status, _hc_le_data_packet_length, _hc_total_num_le_data_packets }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._hc_le_data_packet_length);
        buf.push_u8(self._hc_total_num_le_data_packets);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeReadLocalSupportedFeatures {
}

impl LeReadLocalSupportedFeatures {
    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeReadLocalSupportedFeatures)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x3 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        Ok((_s0, LeReadLocalSupportedFeatures {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeReadLocalSupportedFeaturesResponse {
    _status: ResponseStatus,
    _le_features: Vec<u8>,
}

impl LeReadLocalSupportedFeaturesResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_le_features(&self) -> &[u8] {
        &self._le_features
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeReadLocalSupportedFeaturesResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x3 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _le_features) = call!(_s1, count!(8, call!(read_u8_le)))?;
        Ok((_s2, LeReadLocalSupportedFeaturesResponse { _status, _le_features }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_bytes(&self._le_features);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetRandomAddressCommand {
    _random_address: Vec<u8>,
}

impl LeSetRandomAddressCommand {
    pub fn get_random_address(&self) -> &[u8] {
        &self._random_address
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetRandomAddressCommand)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x5 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _random_address) = call!(_s0, count!(6, call!(read_u8_le)))?;
        Ok((_s1, LeSetRandomAddressCommand { _random_address }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._random_address);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetRandomAddressCommandResponse {
    _status: ResponseStatus,
}

impl LeSetRandomAddressCommandResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetRandomAddressCommandResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x5 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, LeSetRandomAddressCommandResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetAdvertisingParameters {
    _advertising_interval_min: u16,
    _advertising_interval_max: u16,
    _advertising_type: u8,
    _own_address_type: u8,
    _peer_address_type: u8,
    _peer_address: Vec<u8>,
    _advertising_channel_map: u8,
    _advertising_filter_policy: u8,
}

impl LeSetAdvertisingParameters {
    pub fn get_advertising_interval_min(&self) -> u16 {
        self._advertising_interval_min
    }

    pub fn get_advertising_interval_max(&self) -> u16 {
        self._advertising_interval_max
    }

    pub fn get_advertising_type(&self) -> u8 {
        self._advertising_type
    }

    pub fn get_own_address_type(&self) -> u8 {
        self._own_address_type
    }

    pub fn get_peer_address_type(&self) -> u8 {
        self._peer_address_type
    }

    pub fn get_peer_address(&self) -> &[u8] {
        &self._peer_address
    }

    pub fn get_advertising_channel_map(&self) -> u8 {
        self._advertising_channel_map
    }

    pub fn get_advertising_filter_policy(&self) -> u8 {
        self._advertising_filter_policy
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetAdvertisingParameters)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x6 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _advertising_interval_min) = call!(_s0, read_u16_le)?;
        let (_s2, _advertising_interval_max) = call!(_s1, read_u16_le)?;
        let (_s3, _advertising_type) = call!(_s2, read_u8_le)?;
        let (_s4, _own_address_type) = call!(_s3, read_u8_le)?;
        let (_s5, _peer_address_type) = call!(_s4, read_u8_le)?;
        let (_s6, _peer_address) = call!(_s5, count!(6, call!(read_u8_le)))?;
        let (_s7, _advertising_channel_map) = call!(_s6, read_u8_le)?;
        let (_s8, _advertising_filter_policy) = call!(_s7, read_u8_le)?;
        Ok((_s8, LeSetAdvertisingParameters { _advertising_interval_min, _advertising_interval_max, _advertising_type, _own_address_type, _peer_address_type, _peer_address, _advertising_channel_map, _advertising_filter_policy }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._advertising_interval_min);
        buf.push_u16_le(self._advertising_interval_max);
        buf.push_u8(self._advertising_type);
        buf.push_u8(self._own_address_type);
        buf.push_u8(self._peer_address_type);
        buf.push_bytes(&self._peer_address);
        buf.push_u8(self._advertising_channel_map);
        buf.push_u8(self._advertising_filter_policy);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetAdvertisingParametersResponse {
    _status: ResponseStatus,
}

impl LeSetAdvertisingParametersResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetAdvertisingParametersResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x6 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, LeSetAdvertisingParametersResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetAdvertisingData {
    _advertising_data_length: u8,
    _advertising_data_buffer: Vec<u8>,
    _advertising_data: Vec<BasicDataType>,
}

impl LeSetAdvertisingData {
    pub fn get_advertising_data(&self) -> &[BasicDataType] {
        &self._advertising_data
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetAdvertisingData)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x8 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _advertising_data_length) = call!(_s0, read_u8_le)?;
        let (_s2, _advertising_data_buffer) = call!(_s1, count!(_advertising_data_length as usize, call!(read_u8_le)))?;
        let (_, _advertising_data) = call!(_s1.range_to(.._advertising_data_length as usize), many!(call!(BasicDataType::parse)))?;
        Ok((_s2, LeSetAdvertisingData { _advertising_data_length, _advertising_data_buffer, _advertising_data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._advertising_data_length);
        buf.push_bytes(&self._advertising_data_buffer);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetAdvertisingDataResponse {
    _status: ResponseStatus,
}

impl LeSetAdvertisingDataResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetAdvertisingDataResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x8 != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, LeSetAdvertisingDataResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetScanParameters {
    _le_scan_type: u8,
    _le_scan_interval: u16,
    _le_scan_window: u16,
    _own_address_type: u8,
    _scanning_filter_policy: u8,
}

impl LeSetScanParameters {
    pub fn get_le_scan_type(&self) -> u8 {
        self._le_scan_type
    }

    pub fn get_le_scan_interval(&self) -> u16 {
        self._le_scan_interval
    }

    pub fn get_le_scan_window(&self) -> u16 {
        self._le_scan_window
    }

    pub fn get_own_address_type(&self) -> u8 {
        self._own_address_type
    }

    pub fn get_scanning_filter_policy(&self) -> u8 {
        self._scanning_filter_policy
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetScanParameters)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0xB != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _le_scan_type) = call!(_s0, read_u8_le)?;
        let (_s2, _le_scan_interval) = call!(_s1, read_u16_le)?;
        let (_s3, _le_scan_window) = call!(_s2, read_u16_le)?;
        let (_s4, _own_address_type) = call!(_s3, read_u8_le)?;
        let (_s5, _scanning_filter_policy) = call!(_s4, read_u8_le)?;
        Ok((_s5, LeSetScanParameters { _le_scan_type, _le_scan_interval, _le_scan_window, _own_address_type, _scanning_filter_policy }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._le_scan_type);
        buf.push_u16_le(self._le_scan_interval);
        buf.push_u16_le(self._le_scan_window);
        buf.push_u8(self._own_address_type);
        buf.push_u8(self._scanning_filter_policy);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetScanParametersResponse {
    _status: ResponseStatus,
}

impl LeSetScanParametersResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetScanParametersResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0xB != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, LeSetScanParametersResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetScanEnable {
    _le_scan_enable: u8,
    _filter_duplicates: u8,
}

impl LeSetScanEnable {
    pub fn get_le_scan_enable(&self) -> u8 {
        self._le_scan_enable
    }

    pub fn get_filter_duplicates(&self) -> u8 {
        self._filter_duplicates
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetScanEnable)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0xC != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _le_scan_enable) = call!(_s0, read_u8_le)?;
        let (_s2, _filter_duplicates) = call!(_s1, read_u8_le)?;
        Ok((_s2, LeSetScanEnable { _le_scan_enable, _filter_duplicates }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._le_scan_enable);
        buf.push_u8(self._filter_duplicates);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeSetScanEnableResponse {
    _status: ResponseStatus,
}

impl LeSetScanEnableResponse {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn parse<'a>(_s0: State<'a>, _ogf: u8, _ocf: u16) -> PResult<(State<'a>, LeSetScanEnableResponse)> {
        if 0x8 != _ogf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0xC != _ocf {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        Ok((_s1, LeSetScanEnableResponse { _status }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct EndThing {
}

impl EndThing {
    pub fn parse<'a>(_s0: State<'a>) -> PResult<(State<'a>, EndThing)> {
        Ok((_s0, EndThing {  }))
    }

    fn write_bytes(&self, _buf: &mut buffer::BitBuffer) {
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct IncompleteServiceUuid16 {
    _len: u8,
    _uuids: Vec<u16>,
}

impl IncompleteServiceUuid16 {
    pub fn get_uuids(&self) -> &[u16] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, IncompleteServiceUuid16)> {
        if 0x2 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x2)) as usize, call!(read_u16_le)))?;
        Ok((_s1, IncompleteServiceUuid16 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_u16_le(*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct CompleteServiceUuid16 {
    _len: u8,
    _uuids: Vec<u16>,
}

impl CompleteServiceUuid16 {
    pub fn get_uuids(&self) -> &[u16] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, CompleteServiceUuid16)> {
        if 0x3 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x2)) as usize, call!(read_u16_le)))?;
        Ok((_s1, CompleteServiceUuid16 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_u16_le(*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct IncompleteServiceUuid32 {
    _len: u8,
    _uuids: Vec<u32>,
}

impl IncompleteServiceUuid32 {
    pub fn get_uuids(&self) -> &[u32] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, IncompleteServiceUuid32)> {
        if 0x4 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x4)) as usize, call!(read_u32_le)))?;
        Ok((_s1, IncompleteServiceUuid32 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_u32_le(*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct CompleteServiceUuid32 {
    _len: u8,
    _uuids: Vec<u32>,
}

impl CompleteServiceUuid32 {
    pub fn get_uuids(&self) -> &[u32] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, CompleteServiceUuid32)> {
        if 0x5 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x4)) as usize, call!(read_u32_le)))?;
        Ok((_s1, CompleteServiceUuid32 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_u32_le(*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct IncompleteServiceUuid128 {
    _len: u8,
    _uuids: Vec<Vec<u8>>,
}

impl IncompleteServiceUuid128 {
    pub fn get_uuids(&self) -> &[Vec<u8>] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, IncompleteServiceUuid128)> {
        if 0x6 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x10)) as usize, call!(count!(16, call!(read_u8_le)))))?;
        Ok((_s1, IncompleteServiceUuid128 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_bytes(&*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct CompleteServiceUuid128 {
    _len: u8,
    _uuids: Vec<Vec<u8>>,
}

impl CompleteServiceUuid128 {
    pub fn get_uuids(&self) -> &[Vec<u8>] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, CompleteServiceUuid128)> {
        if 0x7 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x10)) as usize, call!(count!(16, call!(read_u8_le)))))?;
        Ok((_s1, CompleteServiceUuid128 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_bytes(&*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ShortenedLocalName {
    _len: u8,
    _local_name: String,
}

impl ShortenedLocalName {
    pub fn get_local_name(&self) -> &String {
        &self._local_name
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ShortenedLocalName)> {
        if 0x8 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _local_name) = call!(_s0, map_res!(call!(read_bytes, _len as usize), |v| String::from_utf8(v)))?;
        Ok((_s1, ShortenedLocalName { _len, _local_name }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(self._local_name.as_bytes());
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct CompleteLocalName {
    _len: u8,
    _local_name: String,
}

impl CompleteLocalName {
    pub fn get_local_name(&self) -> &String {
        &self._local_name
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, CompleteLocalName)> {
        if 0x9 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _local_name) = call!(_s0, map_res!(call!(read_bytes, _len as usize), |v| String::from_utf8(v)))?;
        Ok((_s1, CompleteLocalName { _len, _local_name }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(self._local_name.as_bytes());
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct AdFlags {
    _len: u8,
    _flags: Vec<u8>,
}

impl AdFlags {
    pub fn get_flags(&self) -> &[u8] {
        &self._flags
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, AdFlags)> {
        if 0x1 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _flags) = call!(_s0, count!(_len as usize, call!(read_u8_le)))?;
        Ok((_s1, AdFlags { _len, _flags }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._flags);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ManufacturerSpecificData {
    _len: u8,
    _company_identifier_code: u16,
    _data: Vec<u8>,
}

impl ManufacturerSpecificData {
    pub fn get_company_identifier_code(&self) -> u16 {
        self._company_identifier_code
    }

    pub fn get_data(&self) -> &[u8] {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ManufacturerSpecificData)> {
        if 0xFF != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _company_identifier_code) = call!(_s0, read_u16_le)?;
        let (_s2, _data) = call!(_s1, count!(((_len - 0x2)) as usize, call!(read_u8_le)))?;
        Ok((_s2, ManufacturerSpecificData { _len, _company_identifier_code, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._company_identifier_code);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct TxPowerLevel {
    _level: i8,
}

impl TxPowerLevel {
    pub fn get_level(&self) -> i8 {
        self._level
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, TxPowerLevel)> {
        if 0xA != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x1 != _len {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _level) = call!(_s0, read_i8_le)?;
        Ok((_s1, TxPowerLevel { _level }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_i8(self._level);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct SlaveConnectionIntervalRange {
    _min: u16,
    _max: u16,
}

impl SlaveConnectionIntervalRange {
    pub fn get_min(&self) -> u16 {
        self._min
    }

    pub fn get_max(&self) -> u16 {
        self._max
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, SlaveConnectionIntervalRange)> {
        if 0x12 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x4 != _len {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _min) = call!(_s0, read_u16_le)?;
        let (_s2, _max) = call!(_s1, read_u16_le)?;
        Ok((_s2, SlaveConnectionIntervalRange { _min, _max }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._min);
        buf.push_u16_le(self._max);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ServiceSolicitation16 {
    _len: u8,
    _uuids: Vec<u16>,
}

impl ServiceSolicitation16 {
    pub fn get_uuids(&self) -> &[u16] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ServiceSolicitation16)> {
        if 0x14 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x2)) as usize, call!(read_u16_le)))?;
        Ok((_s1, ServiceSolicitation16 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_u16_le(*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ServiceSolicitation32 {
    _len: u8,
    _uuids: Vec<u32>,
}

impl ServiceSolicitation32 {
    pub fn get_uuids(&self) -> &[u32] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ServiceSolicitation32)> {
        if 0x1F != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x4)) as usize, call!(read_u32_le)))?;
        Ok((_s1, ServiceSolicitation32 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_u32_le(*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ServiceSolicitation128 {
    _len: u8,
    _uuids: Vec<Vec<u8>>,
}

impl ServiceSolicitation128 {
    pub fn get_uuids(&self) -> &[Vec<u8>] {
        &self._uuids
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ServiceSolicitation128)> {
        if 0x15 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuids) = call!(_s0, count!(((_len / 0x10)) as usize, call!(count!(16, call!(read_u8_le)))))?;
        Ok((_s1, ServiceSolicitation128 { _len, _uuids }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for v in &self._uuids { buf.push_bytes(&*v); }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ServiceData16 {
    _len: u8,
    _uuid: u16,
    _data: Vec<u8>,
}

impl ServiceData16 {
    pub fn get_uuid(&self) -> u16 {
        self._uuid
    }

    pub fn get_data(&self) -> &[u8] {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ServiceData16)> {
        if 0x16 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuid) = call!(_s0, read_u16_le)?;
        let (_s2, _data) = call!(_s1, count!(((_len - 0x2)) as usize, call!(read_u8_le)))?;
        Ok((_s2, ServiceData16 { _len, _uuid, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._uuid);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ServiceData32 {
    _len: u8,
    _uuid: u32,
    _data: Vec<u8>,
}

impl ServiceData32 {
    pub fn get_uuid(&self) -> u32 {
        self._uuid
    }

    pub fn get_data(&self) -> &[u8] {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ServiceData32)> {
        if 0x20 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuid) = call!(_s0, read_u32_le)?;
        let (_s2, _data) = call!(_s1, count!(((_len - 0x4)) as usize, call!(read_u8_le)))?;
        Ok((_s2, ServiceData32 { _len, _uuid, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u32_le(self._uuid);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct ServiceData128 {
    _len: u8,
    _uuid: Vec<u8>,
    _data: Vec<u8>,
}

impl ServiceData128 {
    pub fn get_uuid(&self) -> &[u8] {
        &self._uuid
    }

    pub fn get_data(&self) -> &[u8] {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, ServiceData128)> {
        if 0x21 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _uuid) = call!(_s0, count!(16, call!(read_u8_le)))?;
        let (_s2, _data) = call!(_s1, count!(((_len - 0x10)) as usize, call!(read_u8_le)))?;
        Ok((_s2, ServiceData128 { _len, _uuid, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._uuid);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct Appearance {
    _appearance: u16,
}

impl Appearance {
    pub fn get_appearance(&self) -> u16 {
        self._appearance
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, Appearance)> {
        if 0x19 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        if 0x2 != _len {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _appearance) = call!(_s0, read_u16_le)?;
        Ok((_s1, Appearance { _appearance }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u16_le(self._appearance);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct BasicDataType {
    _length: u8,
    _type: u8,
    _data: BasicDataType_Data,
}

impl BasicDataType {
    pub fn get_data(&self) -> &BasicDataType_Data {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>) -> PResult<(State<'a>, BasicDataType)> {
        let (_s1, _length) = call!(_s0, read_u8_le)?;
        let (_s2, _type) = call!(_s1, read_u8_le)?;
        let (_s3, _data) = call!(_s2, choose!(
            map!(call!(call!(IncompleteServiceUuid16::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::IncompleteServiceUuid16(v)) |
            map!(call!(call!(CompleteServiceUuid16::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::CompleteServiceUuid16(v)) |
            map!(call!(call!(IncompleteServiceUuid32::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::IncompleteServiceUuid32(v)) |
            map!(call!(call!(CompleteServiceUuid32::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::CompleteServiceUuid32(v)) |
            map!(call!(call!(IncompleteServiceUuid128::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::IncompleteServiceUuid128(v)) |
            map!(call!(call!(CompleteServiceUuid128::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::CompleteServiceUuid128(v)) |
            map!(call!(call!(ShortenedLocalName::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ShortenedLocalName(v)) |
            map!(call!(call!(CompleteLocalName::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::CompleteLocalName(v)) |
            map!(call!(call!(AdFlags::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ADFlags(v)) |
            map!(call!(call!(ManufacturerSpecificData::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ManufacturerSpecificData(v)) |
            map!(call!(call!(TxPowerLevel::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::TxPowerLevel(v)) |
            map!(call!(call!(SlaveConnectionIntervalRange::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::SlaveConnectionIntervalRange(v)) |
            map!(call!(call!(ServiceSolicitation16::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ServiceSolicitation16(v)) |
            map!(call!(call!(ServiceSolicitation32::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ServiceSolicitation32(v)) |
            map!(call!(call!(ServiceSolicitation128::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ServiceSolicitation128(v)) |
            map!(call!(call!(ServiceData16::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ServiceData16(v)) |
            map!(call!(call!(ServiceSolicitation32::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ServiceData32(v)) |
            map!(call!(call!(ServiceData128::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::ServiceData128(v)) |
            map!(call!(call!(Appearance::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::Appearance(v)) |
            map!(call!(call!(UnsupportedDataType::parse, _type, (_length - 0x1))), |v| BasicDataType_Data::UnsupportedDataType(v))
    ))?;
        Ok((_s3, BasicDataType { _length, _type, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._length);
        buf.push_u8(self._type);
        match &self._data {
            BasicDataType_Data::IncompleteServiceUuid16(v) => v.write_bytes(buf),
            BasicDataType_Data::CompleteServiceUuid16(v) => v.write_bytes(buf),
            BasicDataType_Data::IncompleteServiceUuid32(v) => v.write_bytes(buf),
            BasicDataType_Data::CompleteServiceUuid32(v) => v.write_bytes(buf),
            BasicDataType_Data::IncompleteServiceUuid128(v) => v.write_bytes(buf),
            BasicDataType_Data::CompleteServiceUuid128(v) => v.write_bytes(buf),
            BasicDataType_Data::ShortenedLocalName(v) => v.write_bytes(buf),
            BasicDataType_Data::CompleteLocalName(v) => v.write_bytes(buf),
            BasicDataType_Data::ADFlags(v) => v.write_bytes(buf),
            BasicDataType_Data::ManufacturerSpecificData(v) => v.write_bytes(buf),
            BasicDataType_Data::TxPowerLevel(v) => v.write_bytes(buf),
            BasicDataType_Data::SlaveConnectionIntervalRange(v) => v.write_bytes(buf),
            BasicDataType_Data::ServiceSolicitation16(v) => v.write_bytes(buf),
            BasicDataType_Data::ServiceSolicitation32(v) => v.write_bytes(buf),
            BasicDataType_Data::ServiceSolicitation128(v) => v.write_bytes(buf),
            BasicDataType_Data::ServiceData16(v) => v.write_bytes(buf),
            BasicDataType_Data::ServiceData32(v) => v.write_bytes(buf),
            BasicDataType_Data::ServiceData128(v) => v.write_bytes(buf),
            BasicDataType_Data::Appearance(v) => v.write_bytes(buf),
            BasicDataType_Data::UnsupportedDataType(v) => v.write_bytes(buf),
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct UnsupportedDataType {
    _type: u8,
    _len: u8,
    _data: Vec<u8>,
}

impl UnsupportedDataType {
    pub fn get_data(&self) -> &[u8] {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8, _len: u8) -> PResult<(State<'a>, UnsupportedDataType)> {
        let (_s1, _data) = call!(_s0, count!(_len as usize, call!(read_u8_le)))?;
        Ok((_s1, UnsupportedDataType { _type, _len, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeMetaEvent {
    _subevent_code: u8,
    _event: LeMetaEvent_Event,
}

impl LeMetaEvent {
    pub fn get_event(&self) -> &LeMetaEvent_Event {
        &self._event
    }

    pub fn parse<'a>(_s0: State<'a>, _event_code: u8) -> PResult<(State<'a>, LeMetaEvent)> {
        if 0x3E != _event_code {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _subevent_code) = call!(_s0, read_u8_le)?;
        let (_s2, _event) = call!(_s1, choose!(
            map!(call!(call!(LeConnectionComplete::parse, _subevent_code)), |v| LeMetaEvent_Event::LeConnectionComplete(v)) |
            map!(call!(call!(LeAdvertisingReport::parse, _subevent_code)), |v| LeMetaEvent_Event::LeAdvertisingReport(v)) |
            map!(call!(call!(LeConnectionUpdateComplete::parse, _subevent_code)), |v| LeMetaEvent_Event::LeConnectionUpdateComplete(v)) |
            map!(call!(call!(LeReadRemoteFeaturesComplete::parse, _subevent_code)), |v| LeMetaEvent_Event::LeReadRemoteFeaturesComplete(v))
    ))?;
        Ok((_s2, LeMetaEvent { _subevent_code, _event }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._subevent_code);
        match &self._event {
            LeMetaEvent_Event::LeConnectionComplete(v) => v.write_bytes(buf),
            LeMetaEvent_Event::LeAdvertisingReport(v) => v.write_bytes(buf),
            LeMetaEvent_Event::LeConnectionUpdateComplete(v) => v.write_bytes(buf),
            LeMetaEvent_Event::LeReadRemoteFeaturesComplete(v) => v.write_bytes(buf),
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeConnectionComplete {
    _status: ResponseStatus,
    _connection_handle: u16,
    _reserved: u8,
    _role: u8,
    _peer_address_type: u8,
    _peer_address: Vec<u8>,
    _conn_interval: u16,
    _conn_latency: u16,
    _supervision_timeout: u16,
    _master_clock_accuracy: u8,
}

impl LeConnectionComplete {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_connection_handle(&self) -> u16 {
        self._connection_handle
    }

    pub fn get_role(&self) -> u8 {
        self._role
    }

    pub fn get_peer_address_type(&self) -> u8 {
        self._peer_address_type
    }

    pub fn get_peer_address(&self) -> &[u8] {
        &self._peer_address
    }

    pub fn get_conn_interval(&self) -> u16 {
        self._conn_interval
    }

    pub fn get_conn_latency(&self) -> u16 {
        self._conn_latency
    }

    pub fn get_supervision_timeout(&self) -> u16 {
        self._supervision_timeout
    }

    pub fn get_master_clock_accuracy(&self) -> u8 {
        self._master_clock_accuracy
    }

    pub fn parse<'a>(_s0: State<'a>, _subevent_code: u8) -> PResult<(State<'a>, LeConnectionComplete)> {
        if 0x1 != _subevent_code {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _connection_handle) = call!(_s1, call!(read_bits_u16, 12))?;
        let (_s3, _reserved) = call!(_s2, call!(read_bits_u8, 4))?;
        let (_s4, _role) = call!(_s3, read_u8_le)?;
        let (_s5, _peer_address_type) = call!(_s4, read_u8_le)?;
        let (_s6, _peer_address) = call!(_s5, count!(6, call!(read_u8_le)))?;
        let (_s7, _conn_interval) = call!(_s6, read_u16_le)?;
        let (_s8, _conn_latency) = call!(_s7, read_u16_le)?;
        let (_s9, _supervision_timeout) = call!(_s8, read_u16_le)?;
        let (_s10, _master_clock_accuracy) = call!(_s9, read_u8_le)?;
        Ok((_s10, LeConnectionComplete { _status, _connection_handle, _reserved, _role, _peer_address_type, _peer_address, _conn_interval, _conn_latency, _supervision_timeout, _master_clock_accuracy }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        for _v in 0..12 { buf.push_bit(self._connection_handle & (1 << _v) > 0) }
        for _v in 0..4 { buf.push_bit(self._reserved & (1 << _v) > 0) }
        buf.push_u8(self._role);
        buf.push_u8(self._peer_address_type);
        buf.push_bytes(&self._peer_address);
        buf.push_u16_le(self._conn_interval);
        buf.push_u16_le(self._conn_latency);
        buf.push_u16_le(self._supervision_timeout);
        buf.push_u8(self._master_clock_accuracy);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeAdvertisingReport {
    _num_reports: u8,
    _event_type: u8,
    _address_type: u8,
    _address: Vec<u8>,
    _data_len: u8,
    _data_buffer: Vec<u8>,
    _data: Vec<BasicDataType>,
    _rssi: u8,
}

impl LeAdvertisingReport {
    pub fn get_event_type(&self) -> u8 {
        self._event_type
    }

    pub fn get_address_type(&self) -> u8 {
        self._address_type
    }

    pub fn get_address(&self) -> &[u8] {
        &self._address
    }

    pub fn get_data(&self) -> &[BasicDataType] {
        &self._data
    }

    pub fn get_rssi(&self) -> u8 {
        self._rssi
    }

    pub fn parse<'a>(_s0: State<'a>, _subevent_code: u8) -> PResult<(State<'a>, LeAdvertisingReport)> {
        if 0x2 != _subevent_code {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _num_reports) = call!(_s0, read_u8_le)?;
        let (_s2, _event_type) = call!(_s1, read_u8_le)?;
        let (_s3, _address_type) = call!(_s2, read_u8_le)?;
        let (_s4, _address) = call!(_s3, count!(6, call!(read_u8_le)))?;
        let (_s5, _data_len) = call!(_s4, read_u8_le)?;
        let (_s6, _data_buffer) = call!(_s5, count!(_data_len as usize, call!(read_u8_le)))?;
        let (_, _data) = call!(_s5.range_to(.._data_len as usize), many!(call!(BasicDataType::parse)))?;
        let (_s7, _rssi) = call!(_s6, read_u8_le)?;
        Ok((_s7, LeAdvertisingReport { _num_reports, _event_type, _address_type, _address, _data_len, _data_buffer, _data, _rssi }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._num_reports);
        buf.push_u8(self._event_type);
        buf.push_u8(self._address_type);
        buf.push_bytes(&self._address);
        buf.push_u8(self._data_len);
        buf.push_bytes(&self._data_buffer);
        buf.push_u8(self._rssi);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeConnectionUpdateComplete {
    _status: ResponseStatus,
    _connection_handle: u16,
    _conn_interval: u16,
    _conn_latency: u16,
    _supervision_timeout: u16,
}

impl LeConnectionUpdateComplete {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_connection_handle(&self) -> u16 {
        self._connection_handle
    }

    pub fn get_conn_interval(&self) -> u16 {
        self._conn_interval
    }

    pub fn get_conn_latency(&self) -> u16 {
        self._conn_latency
    }

    pub fn get_supervision_timeout(&self) -> u16 {
        self._supervision_timeout
    }

    pub fn parse<'a>(_s0: State<'a>, _subevent_code: u8) -> PResult<(State<'a>, LeConnectionUpdateComplete)> {
        if 0x3 != _subevent_code {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _connection_handle) = call!(_s1, read_u16_le)?;
        let (_s3, _conn_interval) = call!(_s2, read_u16_le)?;
        let (_s4, _conn_latency) = call!(_s3, read_u16_le)?;
        let (_s5, _supervision_timeout) = call!(_s4, read_u16_le)?;
        Ok((_s5, LeConnectionUpdateComplete { _status, _connection_handle, _conn_interval, _conn_latency, _supervision_timeout }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._connection_handle);
        buf.push_u16_le(self._conn_interval);
        buf.push_u16_le(self._conn_latency);
        buf.push_u16_le(self._supervision_timeout);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct LeReadRemoteFeaturesComplete {
    _status: ResponseStatus,
    _connection_handle: u16,
    _le_features: Vec<u8>,
}

impl LeReadRemoteFeaturesComplete {
    pub fn get_status(&self) -> &ResponseStatus {
        &self._status
    }

    pub fn get_connection_handle(&self) -> u16 {
        self._connection_handle
    }

    pub fn get_le_features(&self) -> &[u8] {
        &self._le_features
    }

    pub fn parse<'a>(_s0: State<'a>, _subevent_code: u8) -> PResult<(State<'a>, LeReadRemoteFeaturesComplete)> {
        if 0x4 != _subevent_code {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _status) = call!(_s0, ResponseStatus::parse)?;
        let (_s2, _connection_handle) = call!(_s1, read_u16_le)?;
        let (_s3, _le_features) = call!(_s2, count!(8, call!(read_u8_le)))?;
        Ok((_s3, LeReadRemoteFeaturesComplete { _status, _connection_handle, _le_features }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        (self._status).write_bytes(buf);
        buf.push_u16_le(self._connection_handle);
        buf.push_bytes(&self._le_features);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct HciAclData {
    _handle: u16,
    _packet_boundary_flag: u8,
    _broadcast_flag: u8,
    _data_total_length: u16,
    _data: Vec<u8>,
}

impl HciAclData {
    pub fn get_handle(&self) -> u16 {
        self._handle
    }

    pub fn get_packet_boundary_flag(&self) -> u8 {
        self._packet_boundary_flag
    }

    pub fn get_broadcast_flag(&self) -> u8 {
        self._broadcast_flag
    }

    pub fn get_data(&self) -> &[u8] {
        &self._data
    }

    pub fn parse<'a>(_s0: State<'a>, _type: u8) -> PResult<(State<'a>, HciAclData)> {
        if 0x2 != _type {
            return Err(protogen::Error { error: protogen::ErrorType::Failure, position: _s0.offset * 8 + _s0.bit_offset });
        }
        let (_s1, _handle) = call!(_s0, call!(read_bits_u16, 12))?;
        let (_s2, _packet_boundary_flag) = call!(_s1, call!(read_bits_u8, 2))?;
        let (_s3, _broadcast_flag) = call!(_s2, call!(read_bits_u8, 2))?;
        let (_s4, _data_total_length) = call!(_s3, read_u16_le)?;
        let (_s5, _data) = call!(_s4, count!(_data_total_length as usize, call!(read_u8_le)))?;
        Ok((_s5, HciAclData { _handle, _packet_boundary_flag, _broadcast_flag, _data_total_length, _data }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        for _v in 0..12 { buf.push_bit(self._handle & (1 << _v) > 0) }
        for _v in 0..2 { buf.push_bit(self._packet_boundary_flag & (1 << _v) > 0) }
        for _v in 0..2 { buf.push_bit(self._broadcast_flag & (1 << _v) > 0) }
        buf.push_u16_le(self._data_total_length);
        buf.push_bytes(&self._data);
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub struct HciMessage {
    _message_type: u8,
    _message: HciMessage_Message,
}

impl HciMessage {
    pub fn get_message(&self) -> &HciMessage_Message {
        &self._message
    }

    pub fn parse<'a>(_s0: State<'a>) -> PResult<(State<'a>, HciMessage)> {
        let (_s1, _message_type) = call!(_s0, read_u8_le)?;
        let (_s2, _message) = call!(_s1, choose!(
            map!(call!(call!(HciCommand::parse, _message_type)), |v| HciMessage_Message::HciCommand(v)) |
            map!(call!(call!(HciAclData::parse, _message_type)), |v| HciMessage_Message::HciAclData(v)) |
            map!(call!(call!(HciEvent::parse, _message_type)), |v| HciMessage_Message::HciEvent(v))
    ))?;
        Ok((_s2, HciMessage { _message_type, _message }))
    }

    fn write_bytes(&self, buf: &mut buffer::BitBuffer) {
        buf.push_u8(self._message_type);
        match &self._message {
            HciMessage_Message::HciCommand(v) => v.write_bytes(buf),
            HciMessage_Message::HciAclData(v) => v.write_bytes(buf),
            HciMessage_Message::HciEvent(v) => v.write_bytes(buf),
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut buf = buffer::BitBuffer::new();
        self.write_bytes(&mut buf);
        buf.into_vec()
    }

}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum HciEvent_Event {
    DisconnectionComplete(DisconnectionComplete),
    CommandComplete(CommandComplete),
    LeMetaEvent(LeMetaEvent),
    UnknownEvent(UnknownEvent),
}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum CommandComplete_Response {
    NoAssociatedCommand(NoAssociatedCommand),
    Disconnect(DisconnectResponse),
    Reset(ResetResponse),
    SetEventFilter(SetEventFilterResponse),
    Flush(FlushResponse),
    WriteLocalName(WriteLocalNameResponse),
    ReadLocalName(ReadLocalNameResponse),
    ReadConnectionAcceptTimeout(ReadConnectionAcceptTimeoutResponse),
    WriteConnectionAcceptTimeout(WriteConnectionAcceptTimeoutResponse),
    ReadPageTimeout(ReadPageTimeoutResponse),
    WritePageTimeout(WritePageTimeoutResponse),
    ReadScanEnable(ReadScanEnableResponse),
    WriteScanEnable(WriteScanEnableResponse),
    ReadPageScanActivity(ReadPageScanActivityResponse),
    WritePageScanActivity(WritePageScanActivityResponse),
    ReadInquiryScanActivity(ReadInquiryScanActivityResponse),
    WriteInquiryScanActivity(WriteInquiryScanActivityResponse),
    ReadExtendedInquiryResponse(ReadExtendedInquiryResponseResponse),
    WriteExtendedInquiryResponse(WriteExtendedInquiryResponseResponse),
    ReadLeHostSupport(ReadLeHostSupportResponse),
    WriteLeHostSupport(WriteLeHostSupportResponse),
    LeSetEventMask(LeSetEventMask),
    LeSetEventMaskResponse(LeSetEventMaskResponse),
    LeReadBufferSize(LeReadBufferSizeResponse),
    LeReadLocalSupportedFeatures(LeReadLocalSupportedFeaturesResponse),
    LeSetRandomAddressCommand(LeSetRandomAddressCommandResponse),
    LeSetAdvertisingParameters(LeSetAdvertisingParametersResponse),
    LESetAdvertisingData(LeSetAdvertisingDataResponse),
    LeSetScanParameters(LeSetScanParametersResponse),
    LeSetScanEnable(LeSetScanEnableResponse),
    UnknownCommand(UnknownCommand),
}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum HciCommand_Command {
    Disconnect(Disconnect),
    Reset(Reset),
    SetEventFilter(SetEventFilter),
    Flush(Flush),
    WriteLocalName(WriteLocalName),
    ReadLocalName(ReadLocalName),
    ReadConnectionAcceptTimeout(ReadConnectionAcceptTimeout),
    WriteConnectionAcceptTimeout(WriteConnectionAcceptTimeout),
    ReadPageTimeout(ReadPageTimeout),
    WritePageTimeout(WritePageTimeout),
    ReadScanEnable(ReadScanEnable),
    WriteScanEnable(WriteScanEnable),
    ReadPageScanActivity(ReadPageScanActivity),
    WritePageScanActivity(WritePageScanActivity),
    ReadInquiryScanActivity(ReadInquiryScanActivity),
    WriteInquiryScanActivity(WriteInquiryScanActivity),
    LESetAdvertisingData(LeSetAdvertisingData),
    Unknown(Unknown),
}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum SetEventFilter_Filter {
    ClearAllFilter(ClearAllFilter),
    InquiryResult(InquiryResult),
    ConnectionSetup(ConnectionSetup),
}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum FilterCondition_Value {
    AllDevices(AllDevices),
    MatchClass(MatchClass),
    MatchAddress(MatchAddress),
}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum BasicDataType_Data {
    IncompleteServiceUuid16(IncompleteServiceUuid16),
    CompleteServiceUuid16(CompleteServiceUuid16),
    IncompleteServiceUuid32(IncompleteServiceUuid32),
    CompleteServiceUuid32(CompleteServiceUuid32),
    IncompleteServiceUuid128(IncompleteServiceUuid128),
    CompleteServiceUuid128(CompleteServiceUuid128),
    ShortenedLocalName(ShortenedLocalName),
    CompleteLocalName(CompleteLocalName),
    ADFlags(AdFlags),
    ManufacturerSpecificData(ManufacturerSpecificData),
    TxPowerLevel(TxPowerLevel),
    SlaveConnectionIntervalRange(SlaveConnectionIntervalRange),
    ServiceSolicitation16(ServiceSolicitation16),
    ServiceSolicitation32(ServiceSolicitation32),
    ServiceSolicitation128(ServiceSolicitation128),
    ServiceData16(ServiceData16),
    ServiceData32(ServiceSolicitation32),
    ServiceData128(ServiceData128),
    Appearance(Appearance),
    UnsupportedDataType(UnsupportedDataType),
}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum LeMetaEvent_Event {
    LeConnectionComplete(LeConnectionComplete),
    LeAdvertisingReport(LeAdvertisingReport),
    LeConnectionUpdateComplete(LeConnectionUpdateComplete),
    LeReadRemoteFeaturesComplete(LeReadRemoteFeaturesComplete),
}


#[allow(non_camel_case_types)]
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]
pub enum HciMessage_Message {
    HciCommand(HciCommand),
    HciAclData(HciAclData),
    HciEvent(HciEvent),
}


